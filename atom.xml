<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoinApper</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhuofujiang.github.io/"/>
  <updated>2019-10-13T14:31:03.127Z</updated>
  <id>https://zhuofujiang.github.io/</id>
  
  <author>
    <name>JoinApper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java单例模式</title>
    <link href="https://zhuofujiang.github.io/2019/10/13/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuofujiang.github.io/2019/10/13/Java单例模式/</id>
    <published>2019-10-13T14:31:03.000Z</published>
    <updated>2019-10-13T14:31:03.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型模式之单例模式"><a href="#创建型模式之单例模式" class="headerlink" title="创建型模式之单例模式"></a>创建型模式之单例模式</h1><p>此篇博客主要谈谈创建型模式中的单例模式，包括单例模式的五种实现方式：饿汉式、懒汉式、双重检测锁、静态内部类以及枚举。</p><p>此篇博客主要参考以下文档：</p><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/</a></p><h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><a id="more"></a><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>单例模式包含如下角色：</p><ul><li>Singleton：单例</li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg" alt="../_images/Singleton.jpg"></p><p>上图中实现了懒汉式单例模式，可以延时加载，一定程度上减少了资源的开销。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerSingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HungerSingleton instance = <span class="keyword">new</span> HungerSingleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungerSingleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> HungerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例模式在类加载时便创建了实例对象，客户端调用实例创建方法时直接返回实例即可，该方式是线程安全的。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与饿汉式单例模式不同，懒汉式单例模式直到客户端真正调用实例创建方法时才创建实例，起到了延时加载的作用。</p><p>为了保证线程安全，可以用synchronized修饰方法，另外还能用双重检测锁的方式保证线程安全。</p><h3 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckSingleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，此处采用两次判断instance是否为null的原因，假设多个线程同时通过第一个条件，此时由于synchronized锁，只能有一个线程可以执行后面实例的创建过程，若是没有第二个instance的判断，则在第一个线程创建实例对象后，后续线程将会再次创建对象，因此此时还需要判断instance是否已经被创建。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Singleton.instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要提一下为什么静态内部类是线程安全的，其原因在于：</p><ol><li>只有在访问静态内部类的静态变量方法时，静态内部类才开始加载。</li><li>虚拟机会保证一个类的构造器<clinit>()方法在多线程环境下被正确地加载，同步，如果多个线程同时初始化一个类，只有一个线程会执行这个类的构造器<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)</clinit></clinit></clinit></clinit></clinit></clinit></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//自定义方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于其他方式来说，枚举式单例模式更加简洁。</p><h3 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h3><ul><li>饿汉式（线程安全，调用效率高，不能够延时加载）</li><li>懒汉式（线程安全，调用效率不高，可以延时加载）</li><li>双重检测锁（由于JVM底层原因，偶尔会出问题）</li><li>静态内部类（线程安全，调用效率高，可以延时加载）</li><li>枚举（线程安全，调用效率高，不能延时加载，天然地防止反射和反序列化）</li></ul><p>单例对象占用资源小，不需要延时加载：枚举好于饿汉单例。</p><p>对象占用资源大，需要延时加载：静态内部类好于懒汉。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li>单例类的构造函数为私有；</li><li>提供一个自身的静态私有成员变量；</li><li>提供一个公有的静态工厂方法。</li></ul><h2 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h2><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h2 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h2><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建型模式之单例模式&quot;&gt;&lt;a href=&quot;#创建型模式之单例模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式之单例模式&quot;&gt;&lt;/a&gt;创建型模式之单例模式&lt;/h1&gt;&lt;p&gt;此篇博客主要谈谈创建型模式中的单例模式，包括单例模式的五种实现方式：饿汉式、懒汉式、双重检测锁、静态内部类以及枚举。&lt;/p&gt;
&lt;p&gt;此篇博客主要参考以下文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://design-patterns.readthedocs.io/zh_CN/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://design-patterns.readthedocs.io/zh_CN/latest/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h2&gt;&lt;p&gt;对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。&lt;/p&gt;
&lt;p&gt;如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。&lt;/p&gt;
&lt;p&gt;一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zhuofujiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://zhuofujiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://zhuofujiang.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhuofujiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java工厂模式</title>
    <link href="https://zhuofujiang.github.io/2019/10/12/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zhuofujiang.github.io/2019/10/12/Java工厂模式/</id>
    <published>2019-10-12T14:27:41.000Z</published>
    <updated>2019-10-13T14:30:37.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型模式之工厂模式"><a href="#创建型模式之工厂模式" class="headerlink" title="创建型模式之工厂模式"></a>创建型模式之工厂模式</h1><p>此篇博客简要谈谈创建型模式中的工厂模式，包括简单工厂模式、工厂方法模式以及抽象工厂模式。</p><p>此篇博客主要参考以下文档：</p><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/</a></p><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><a id="more"></a><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例，具体实现时可以通过调用不同方法创建实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>简单工厂模式包含如下角色：</p><ul><li><p>Factory：工厂角色</p><p>工厂角色负责实现创建所有实例的内部逻辑</p></li><li><p>Product：抽象产品角色</p><p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p></li><li><p>ConcreteProduct：具体产品角色</p><p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>考虑需要一辆车(Car)，车的品牌可以随便我们挑(不同品牌的车继承自Car类)，只需要和前台服务小姐姐说一声， 然后前台将品牌信息传递给车厂(参数传递)，车厂再根据此参数制造一辆新车(new一个Car实例)，最后便可以开车出去旅游了，最终的UML类图如下：</p><p><img src="CarFactory.png" alt="CarFactory"></p><p>车辆基类Car:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宝马Car:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BM</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"我是宝马"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比亚迪Car:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BYD</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"我是比亚迪"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>造车工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(name.equals(<span class="string">"宝马"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BM();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">"比亚迪"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BYD();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">Car car = factory.createCar(<span class="string">"宝马"</span>); <span class="comment">//传递不同的参数获得不同品牌车辆</span></span><br><span class="line">car.move();</span><br><span class="line">Car car2 = factory.createCar(<span class="string">"比亚迪"</span>);</span><br><span class="line">car2.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h3><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。</li></ul><h3 id="模式缺点"><a href="#模式缺点" class="headerlink" title="模式缺点"></a>模式缺点</h3><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用简单工厂模式：</p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ul><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h3 id="模式动机-1"><a href="#模式动机-1" class="headerlink" title="模式动机"></a>模式动机</h3><p>现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p><h3 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p>工厂方法模式包含如下角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="../_images/FactoryMethod.jpg"></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>考虑需要一辆车(Car)，车的品牌可以随便我们挑(不同品牌的车继承自Car类)，只需要和前台服务小姐姐说一声， 然后前台依据不同的品牌通知相应的车厂，然后车厂制造一辆新车(new一个Car实例)，最后便可以开车出去旅游了，最终的UML类图如下：</p><p><img src="FactoryMethod.png" alt="FactoryMethod"></p><p>车辆类的结构和上述简单工厂中的一样，但是在工厂方法中不同的品牌对应不同的工厂。</p><p>造车工厂基类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function">Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宝马车厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BM();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比亚迪车厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BYDFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BYD();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory bmFactory = <span class="keyword">new</span> BMFactory(); <span class="comment">//不同车厂构造不同品牌的车辆</span></span><br><span class="line">Factory bydFactory = <span class="keyword">new</span> BYDFactory();</span><br><span class="line">Car car = bmFactory.createCar();</span><br><span class="line">Car car2 = bydFactory.createCar();</span><br><span class="line">car.move();</span><br><span class="line">car2.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式优点-1"><a href="#模式优点-1" class="headerlink" title="模式优点"></a>模式优点</h3><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="模式缺点-1"><a href="#模式缺点-1" class="headerlink" title="模式缺点"></a>模式缺点</h3><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="模式动机-2"><a href="#模式动机-2" class="headerlink" title="模式动机"></a>模式动机</h3><ul><li><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p><blockquote><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><ul><li><strong>产品等级结构</strong> ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li><li><strong>产品族</strong> ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li></ul></blockquote></li><li><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p></li><li><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p></li></ul><h3 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p><h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><p>抽象工厂模式包含如下角色：</p><ul><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ul><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="../_images/AbatractFactory.jpg"></p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>考虑需要组装一辆车，包括引擎、坐垫以及轮胎，则好引擎、好坐垫以及好轮胎构成一个产品族，坏引擎、坏坐垫以及坏轮胎构成一个产品族；好引擎和坏引擎继承于发动机，属于同个产品等级结构，坐垫以及轮胎同理。</p><p><img src="AbstractFactory.png" alt="AbstractFactory"></p><p>引擎类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"转得快"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"转得慢"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坐垫类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"坐的舒服"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"坐的想死"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轮胎类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tyre</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighTyre</span> <span class="keyword">implements</span> <span class="title">Tyre</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"好轮胎跑得快"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowTyre</span> <span class="keyword">implements</span> <span class="title">Tyre</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"坏轮胎跑得慢"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"><span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Seat <span class="title">createSeat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Tyre <span class="title">createTyre</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HighEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HighSeat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HighTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Factory factory = <span class="keyword">new</span> HighFactory(); <span class="comment">//创建好坏两种产品族</span></span><br><span class="line">Engine engine = factory.createEngine();</span><br><span class="line">engine.run();</span><br><span class="line">Factory factory2 = <span class="keyword">new</span> LowFactory();</span><br><span class="line">Engine engine2 = factory2.createEngine();</span><br><span class="line">engine2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模式优点-2"><a href="#模式优点-2" class="headerlink" title="模式优点"></a>模式优点</h3><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h3 id="模式缺点-2"><a href="#模式缺点-2" class="headerlink" title="模式缺点"></a>模式缺点</h3><ul><li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</li><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用抽象工厂模式：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</li><li>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li><li>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><h2 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h2><p>总的来说，三种工厂模式核心要点各不相同。在简单工厂中，一个工厂可以通过不同的参数创建不同的产品；在工厂方法中，不同的产品则要通过不同的工厂创建，相对于简单工厂而言，扩展性更强，但同时会增加类太多难以管理的风险；在抽象工厂中，其主要关注产品族的创建，而非单个产品，增加新的具体工厂和产品族很方便，但是增加新的产品等级结构时很复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建型模式之工厂模式&quot;&gt;&lt;a href=&quot;#创建型模式之工厂模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式之工厂模式&quot;&gt;&lt;/a&gt;创建型模式之工厂模式&lt;/h1&gt;&lt;p&gt;此篇博客简要谈谈创建型模式中的工厂模式，包括简单工厂模式、工厂方法模式以及抽象工厂模式。&lt;/p&gt;
&lt;p&gt;此篇博客主要参考以下文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://design-patterns.readthedocs.io/zh_CN/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://design-patterns.readthedocs.io/zh_CN/latest/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h2&gt;&lt;h3 id=&quot;模式动机&quot;&gt;&lt;a href=&quot;#模式动机&quot; class=&quot;headerlink&quot; title=&quot;模式动机&quot;&gt;&lt;/a&gt;模式动机&lt;/h3&gt;&lt;p&gt;考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://zhuofujiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://zhuofujiang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://zhuofujiang.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhuofujiang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://zhuofujiang.github.io/2019/10/12/UML/"/>
    <id>https://zhuofujiang.github.io/2019/10/12/UML/</id>
    <published>2019-10-12T05:58:07.000Z</published>
    <updated>2019-10-12T06:00:00.927Z</updated>
    
    <content type="html"><![CDATA[<p>此篇博客转载：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p><p>这里只讲讲几个基本的UML元素，其目的旨在看懂类图之间的关系，明白类图之间的线条、箭头代表的含义。</p><h2 id="从一个示例开始"><a href="#从一个示例开始" class="headerlink" title="从一个示例开始"></a>从一个示例开始</h2><p>请看以下这个类图，类之间的关系是我们需要关注的：</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt="_images/uml_class_struct.jpg"></p><a id="more"></a><ul><li>车的类图结构为&lt;<abstract>&gt;，表示车是一个抽象类；</abstract></li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>{</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><p>下面我们将介绍这六种关系；</p><hr><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：</p><p>例子：自行车是车、猫是动物</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt="_images/uml_generalization.jpg"></p><p>例子：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt="_images/uml_generalize.jpg"></p><p>注：最终代码中，泛化关系表现为继承非抽象类；</p><h3 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h3><p>实现关系用一条带空心箭头的虚线表示；</p><p>例子：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt="_images/uml_realize.jpg"></p><p>注：最终代码中，实现关系表现为继承抽象类；</p><h3 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt="_images/uml_aggregation.jpg"></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h3 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt="_images/uml_composition.jpg"></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt="_images/uml_association.jpg"></p><p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p><h3 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt="_images/uml_dependency.jpg"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>为了展示对象之间的交互细节，后续对设计模式解析的章节，都会用到时序图；</p><p>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。</p><p>时序图包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。</p><p>关于时序图，以下这篇文章将概念介绍的比较详细：</p><p><a href="http://smartlife.blog.51cto.com/1146871/284874" target="_blank" rel="noopener">http://smartlife.blog.51cto.com/1146871/284874</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇博客转载：&lt;a href=&quot;https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里只讲讲几个基本的UML元素，其目的旨在看懂类图之间的关系，明白类图之间的线条、箭头代表的含义。&lt;/p&gt;
&lt;h2 id=&quot;从一个示例开始&quot;&gt;&lt;a href=&quot;#从一个示例开始&quot; class=&quot;headerlink&quot; title=&quot;从一个示例开始&quot;&gt;&lt;/a&gt;从一个示例开始&lt;/h2&gt;&lt;p&gt;请看以下这个类图，类之间的关系是我们需要关注的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg&quot; alt=&quot;_images/uml_class_struct.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="UML" scheme="https://zhuofujiang.github.io/categories/UML/"/>
    
      <category term="UML简述" scheme="https://zhuofujiang.github.io/categories/UML/UML%E7%AE%80%E8%BF%B0/"/>
    
    
      <category term="UML" scheme="https://zhuofujiang.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>量子力学</title>
    <link href="https://zhuofujiang.github.io/2019/09/25/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
    <id>https://zhuofujiang.github.io/2019/09/25/量子力学/</id>
    <published>2019-09-25T14:47:41.000Z</published>
    <updated>2019-09-26T02:57:31.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="量子力学简史"><a href="#量子力学简史" class="headerlink" title="量子力学简史"></a>量子力学简史</h1><p>此篇文档由《上帝掷骰子吗》粗略整理而成，如有不当之处，还望不吝指教，自不胜感激！</p><h2 id="光学发展"><a href="#光学发展" class="headerlink" title="光学发展"></a>光学发展</h2><p>量子力学的诞生与光学研究有着紧密的联系，甚至可以说对光的研究直接催生出了量子力学。这部分历史大致可以分为三个阶段：</p><ul><li><p>第一次波粒大战</p><p>波动学说代表人物：<strong>胡克，惠更斯</strong></p><p>微粒学说代表人物：<strong>牛顿（色散实验）</strong></p></li></ul><a id="more"></a><ul><li><p>第二次波粒大战</p><p>波动学说代表人物：<strong>托马斯杨（双缝干涉）</strong>，<strong>菲涅尔（衍射）</strong>，<strong>麦克斯韦（电磁理论）</strong></p><p>微粒学说代表人物：<strong>马吕斯</strong>（<strong>偏振现象</strong>，而波动学说假设光是一种横波，解决此问题）</p></li><li><p>第三次波粒大战</p><p>波动学说代表人物：<strong>德布罗意（相波）</strong></p><p>微粒学说代表人物：<strong>爱因斯坦</strong>（<strong>光电效应</strong>，提出光量子），<strong>康普顿（康普顿效应）</strong></p></li></ul><p>而爱因斯坦的光量子假说，实质上是引入了普朗克量子假设的结果，而量子力学的诞生也正是由普朗克拉开了序幕。</p><h2 id="量子力学发展"><a href="#量子力学发展" class="headerlink" title="量子力学发展"></a>量子力学发展</h2><p>量子力学发展也可以分为三个阶段：</p><ul><li><p>量子初现</p><p>普朗克研究维恩定律与瑞利-金斯定律的基础上，假设能量是不连续的，创造性地提出了量子的概念，并通过普朗克方程描述了单个量子的能量。<br>$$<br>E = hv<br>$$</p></li><li><p>量子巩固</p><p>这是量子力学发展的黄金时期，涌现出了相当多的优秀年轻科学家。</p><p><strong>卢瑟福</strong>：于1911年提出<strong>原子模型</strong>，原子由原子核和电子组成。但是这种模型在经典电磁学理论中，由于不断释放辐射能量，最终将会崩塌。</p><p><strong>玻尔</strong>：于1913年，完成原子模型三论文，并在之后提出<strong>量子模型</strong>。在此模型中，能量与电子运动方向均不连续；为了解决波粒问题，提出<strong>互补原理</strong>，即电子是波还是粒子，取决于我们观测的方式。</p><p><strong>德布罗意</strong>：于1923年提出<strong>相波</strong>的概念，发现电子以速度v运动时，伴随着速度为c^2/v的波。<br>$$<br>\lambda = (c^2/v_1)/(mc^2/h)=h/mv_0<br>$$<br><strong>海森堡</strong>：于1925年提出<strong>矩阵力学</strong>（值得一提的是，海森堡本人重新发明了矩阵）；1927年提出<strong>测不确定性</strong>，永远不可能同时观测到一个电子的动量及位置。</p><p><strong>薛定谔</strong>：于1926年提出<strong>波动方程</strong>，事实证明其与海森堡的矩阵力学实质上是同一体系，波恩认为其中的波函数是一种概率分布。</p><p><strong>狄拉克</strong>：于1928年将相对论引入量子力学，提出<strong>狄拉克方程</strong>。</p></li><li><p>新的征途</p><p>对于量子力学背后的解释，除了哥本哈根解释外，还有很多其他观点，下述只列举部分较为著名的解释观点。</p><p>冯诺依曼：无限复归链</p><p>维格纳：意识论</p><p>埃弗莱特：多世界理论</p><p>盖尔曼：退相干理论</p><p>玻姆：隐变量</p><p>贝尔：贝尔不等式</p></li></ul><p>量子力学仍然在发展，相信终有一天，我们能够真正抓住这个幽灵的秘密！</p><p><img src="量子力学.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;量子力学简史&quot;&gt;&lt;a href=&quot;#量子力学简史&quot; class=&quot;headerlink&quot; title=&quot;量子力学简史&quot;&gt;&lt;/a&gt;量子力学简史&lt;/h1&gt;&lt;p&gt;此篇文档由《上帝掷骰子吗》粗略整理而成，如有不当之处，还望不吝指教，自不胜感激！&lt;/p&gt;
&lt;h2 id=&quot;光学发展&quot;&gt;&lt;a href=&quot;#光学发展&quot; class=&quot;headerlink&quot; title=&quot;光学发展&quot;&gt;&lt;/a&gt;光学发展&lt;/h2&gt;&lt;p&gt;量子力学的诞生与光学研究有着紧密的联系，甚至可以说对光的研究直接催生出了量子力学。这部分历史大致可以分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次波粒大战&lt;/p&gt;
&lt;p&gt;波动学说代表人物：&lt;strong&gt;胡克，惠更斯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微粒学说代表人物：&lt;strong&gt;牛顿（色散实验）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="physical" scheme="https://zhuofujiang.github.io/categories/physical/"/>
    
    
      <category term="历史" scheme="https://zhuofujiang.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>YearPlan</title>
    <link href="https://zhuofujiang.github.io/2019/09/11/YearPlan/"/>
    <id>https://zhuofujiang.github.io/2019/09/11/YearPlan/</id>
    <published>2019-09-11T05:20:27.000Z</published>
    <updated>2019-09-26T01:05:20.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新的学期，新的开始！"><a href="#新的学期，新的开始！" class="headerlink" title="新的学期，新的开始！"></a>新的学期，新的开始！</h1><p>吾早前便已有建此博客之想法，但一者事物繁杂，身陷泥淖难以自拔，二者也未知从何开始，记录什么内容。但在学习人工智能、计算机基础过程中，尤以资料搜寻最耗时耗力，因此自今日始，若偶有所得，便当记录于此，与诸君共享，增一丝趣味罢了。</p><p>以下为己学习之路线规划，望己能秉持自身，勤勉苦学。</p><a id="more"></a><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><em>操作系统</em></h3></li><li><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><em>计算机网络</em></h3></li><li><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><em>数据库</em></h3></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><em>数组</em></h3></li><li><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a><em>链表</em></h3></li><li><h3 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a><em>队列与栈</em></h3></li><li><h3 id="树与堆"><a href="#树与堆" class="headerlink" title="树与堆"></a><em>树与堆</em></h3></li><li><h3 id="图"><a href="#图" class="headerlink" title="图"></a><em>图</em></h3></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><em>贪心</em></h3></li><li><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><em>递归</em></h3></li><li><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><em>动态规划</em></h3></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a><em>线性代数</em></h3></li><li><h3 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a><em>概率统计</em></h3></li><li><h3 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a><em>数学分析</em></h3></li></ul><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul><li><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a><em>计算机视觉</em></h3></li><li><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a><em>自然语言处理</em></h3></li></ul><h2 id="信号与系统"><a href="#信号与系统" class="headerlink" title="信号与系统"></a>信号与系统</h2><h2 id="天文地理"><a href="#天文地理" class="headerlink" title="天文地理"></a>天文地理</h2><ul><li><h3 id="宇宙"><a href="#宇宙" class="headerlink" title="宇宙"></a><em>宇宙</em></h3></li></ul><h2 id="人文历史"><a href="#人文历史" class="headerlink" title="人文历史"></a>人文历史</h2><ul><li><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a><em>历史</em></h3></li></ul><h2 id="杂文"><a href="#杂文" class="headerlink" title="杂文"></a>杂文</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新的学期，新的开始！&quot;&gt;&lt;a href=&quot;#新的学期，新的开始！&quot; class=&quot;headerlink&quot; title=&quot;新的学期，新的开始！&quot;&gt;&lt;/a&gt;新的学期，新的开始！&lt;/h1&gt;&lt;p&gt;吾早前便已有建此博客之想法，但一者事物繁杂，身陷泥淖难以自拔，二者也未知从何开始，记录什么内容。但在学习人工智能、计算机基础过程中，尤以资料搜寻最耗时耗力，因此自今日始，若偶有所得，便当记录于此，与诸君共享，增一丝趣味罢了。&lt;/p&gt;
&lt;p&gt;以下为己学习之路线规划，望己能秉持自身，勤勉苦学。&lt;/p&gt;
    
    </summary>
    
    
      <category term="plan" scheme="https://zhuofujiang.github.io/categories/plan/"/>
    
    
      <category term="life" scheme="https://zhuofujiang.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhuofujiang.github.io/2019/09/10/hello-world/"/>
    <id>https://zhuofujiang.github.io/2019/09/10/hello-world/</id>
    <published>2019-09-10T14:52:09.672Z</published>
    <updated>2019-09-26T01:05:42.212Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://zhuofujiang.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://zhuofujiang.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>HelloHexo</title>
    <link href="https://zhuofujiang.github.io/2019/03/08/HelloHexo/"/>
    <id>https://zhuofujiang.github.io/2019/03/08/HelloHexo/</id>
    <published>2019-03-08T05:34:07.000Z</published>
    <updated>2019-03-08T05:34:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
